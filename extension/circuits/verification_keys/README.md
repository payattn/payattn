# ZK-SNARK Verification Keys for Backend

**Purpose:** These verification keys are used by advertisers/backend to verify proofs generated by the extension.

## Overview

When a user generates a ZK-SNARK proof in the extension, the proof is sent to the backend for verification. The backend uses these verification keys to cryptographically verify that:
1. The proof is valid
2. The proof was generated for the correct circuit
3. The public inputs match what the advertiser expects

## Verification Keys

### `age_range_verification_key.json`
- **Circuit:** age_range
- **Purpose:** Verify user's age is within a specified range
- **Private Input:** User's actual age (never revealed)
- **Public Inputs:** minAge, maxAge (campaign requirements)
- **Use Case:** Age-restricted campaigns (18+, 21+, etc.)

### `range_check_verification_key.json`
- **Circuit:** range_check
- **Purpose:** Generic range verification for any numeric value
- **Private Input:** Value (age, income, credit score, etc.)
- **Public Inputs:** min, max (bounds)
- **Use Cases:** 
  - Income verification ($25k-$50k)
  - Credit score verification (650-850)
  - Any numeric range proof

### `set_membership_verification_key.json`
- **Circuit:** set_membership
- **Purpose:** Verify a value exists in a set (without revealing which one)
- **Private Input:** Hashed value (e.g., hash of user's country)
- **Public Inputs:** Array of hashed allowed values (max 10)
- **Use Cases:**
  - Location verification (user in [US, UK, CA])
  - Interest verification (user interested in [tech, finance, health])
  - Any categorical membership proof

## Backend Integration

### Node.js Example

```javascript
const snarkjs = require('snarkjs');
const fs = require('fs');

// Load verification key
const vKey = JSON.parse(
  fs.readFileSync('circuits/verification_keys/age_range_verification_key.json')
);

// Verify proof from extension
async function verifyProof(proofData) {
  const { proof, publicSignals } = proofData;
  
  const verified = await snarkjs.groth16.verify(
    vKey,
    publicSignals,
    proof
  );
  
  return verified;  // true if valid, false otherwise
}

// Usage
const proofFromExtension = {
  proof: {
    pi_a: [...],
    pi_b: [...],
    pi_c: [...],
    protocol: 'groth16',
    curve: 'bn128'
  },
  publicSignals: ['1', '18', '65']  // valid=1, minAge=18, maxAge=65
};

const isValid = await verifyProof(proofFromExtension);
console.log('Proof is valid:', isValid);
```

### Python Example

```python
import json
from py_ecc.bn128 import G1, G2, pairing
from eth_utils import keccak

# Load verification key
with open('circuits/verification_keys/age_range_verification_key.json') as f:
    vkey = json.load(f)

def verify_proof(proof, public_signals):
    """
    Verify a Groth16 proof
    Note: This is a simplified example. Use a proper library like:
    - snarkjs (via subprocess)
    - gnark
    - bellman
    """
    # Implementation depends on your chosen library
    pass

# Or use snarkjs via subprocess
import subprocess
import json

def verify_proof_snarkjs(proof_file, public_file, vkey_file):
    result = subprocess.run([
        'snarkjs', 'groth16', 'verify',
        vkey_file,
        public_file,
        proof_file
    ], capture_output=True, text=True)
    
    return 'OK' in result.stdout

is_valid = verify_proof_snarkjs('proof.json', 'public.json', 'age_range_verification_key.json')
print(f'Proof is valid: {is_valid}')
```

## Verification Workflow

### 1. Extension Generates Proof

```javascript
// In extension service worker
const proof = await generateProofInServiceWorker('age_range',
  { age: 30 },           // Private
  { minAge: 18, maxAge: 65 }  // Public
);

// POST to backend
await fetch('https://api.example.com/verify', {
  method: 'POST',
  body: JSON.stringify({
    circuitName: 'age_range',
    proof: proof.proof,
    publicSignals: proof.publicSignals
  })
});
```

### 2. Backend Verifies Proof

```javascript
// Backend API endpoint
app.post('/verify', async (req, res) => {
  const { circuitName, proof, publicSignals } = req.body;
  
  // Load correct verification key
  const vKey = loadVerificationKey(circuitName);
  
  // Verify proof
  const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);
  
  if (isValid) {
    // Extract public inputs
    const [valid, minAge, maxAge] = publicSignals;
    
    if (valid === '1') {
      // Proof is valid and constraints satisfied
      // User's age is in range [minAge, maxAge]
      
      // Check if this matches campaign requirements
      const campaign = getCampaign(req.body.campaignId);
      if (minAge == campaign.minAge && maxAge == campaign.maxAge) {
        // ✅ User qualifies for campaign
        res.json({ verified: true });
      } else {
        // ❌ Public inputs don't match campaign
        res.json({ verified: false, reason: 'Age range mismatch' });
      }
    } else {
      // ❌ Constraint not satisfied (should never happen if proof is valid)
      res.json({ verified: false, reason: 'Constraint failed' });
    }
  } else {
    // ❌ Invalid proof
    res.json({ verified: false, reason: 'Invalid proof' });
  }
});
```

### 3. Important Checks

When verifying proofs, always:

✅ **Verify the proof cryptographically**
```javascript
const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);
```

✅ **Check public signals match expectations**
```javascript
const [valid, minAge, maxAge] = publicSignals;
if (minAge !== campaign.minAge || maxAge !== campaign.maxAge) {
  // Proof is for wrong range!
  return false;
}
```

✅ **Check the circuit name**
```javascript
if (req.body.circuitName !== 'age_range') {
  // Wrong circuit!
  return false;
}
```

❌ **Don't trust unverified claims**
```javascript
// WRONG: Don't trust user's claim without verification
if (req.body.userAge >= campaign.minAge) {  // ❌ User could lie
  // allow access
}

// RIGHT: Only trust cryptographically verified proof
if (await verifyProof(proof, publicSignals)) {  // ✅ Mathematically guaranteed
  // allow access
}
```

## Set Membership Verification

For `set_membership` circuit, you must hash the allowed values:

```javascript
const crypto = require('crypto');

const FIELD_PRIME = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617');

function hashToField(str) {
  const hash = crypto.createHash('sha256').update(str, 'utf8').digest();
  const num = BigInt('0x' + hash.toString('hex'));
  return (num % FIELD_PRIME).toString();
}

async function verifyLocationProof(proof, publicSignals, allowedCountries) {
  // Hash the allowed countries
  const expectedHashes = allowedCountries.map(hashToField);
  
  // Pad to 10
  while (expectedHashes.length < 10) {
    expectedHashes.push('0');
  }
  
  // Verify proof
  const vKey = loadVerificationKey('set_membership');
  const isValid = await snarkjs.groth16.verify(vKey, publicSignals, proof);
  
  if (!isValid) return false;
  
  // Check public signals match expected set
  const [isMember, ...publicSet] = publicSignals;
  const setsMatch = publicSet.every((val, i) => val === expectedHashes[i]);
  
  return isMember === '1' && setsMatch;
}

// Usage
const isValid = await verifyLocationProof(
  proof,
  publicSignals,
  ['us', 'uk', 'ca', 'au', 'de']  // Campaign's allowed countries
);
```

**See `HASHING_SCHEME.md` for detailed documentation on the hashing algorithm.**

## Security Considerations

### ✅ DO

- Always verify proofs cryptographically
- Check public signals match your expectations
- Use the correct verification key for each circuit
- Keep verification keys in version control (they're public)
- Rate-limit verification endpoints
- Log verification attempts for fraud detection

### ❌ DON'T

- Trust unverified user claims
- Accept proofs for wrong circuits
- Skip public signal validation
- Treat all proofs as equal (check circuit type!)
- Expose private proving keys (these verification keys are safe)

## Testing Verification

### Test Vectors

Use these to verify your implementation works:

1. **Generate proof in extension**
   ```javascript
   // In browser console with extension loaded
   const proof = await testServiceWorkerProof(30, 18, 65);
   console.log(JSON.stringify(proof, null, 2));
   ```

2. **Save proof to file**
   ```bash
   # Copy output from console
   echo '<paste proof JSON>' > test_proof.json
   ```

3. **Verify on backend**
   ```bash
   # Extract components
   node -e "
   const proof = require('./test_proof.json');
   const fs = require('fs');
   fs.writeFileSync('proof_only.json', JSON.stringify(proof.proof));
   fs.writeFileSync('public_only.json', JSON.stringify(proof.publicSignals));
   "
   
   # Verify with snarkjs
   snarkjs groth16 verify \\
     age_range_verification_key.json \\
     public_only.json \\
     proof_only.json
   
   # Should output: [INFO]  snarkJS: OK!
   ```

## Dependencies

Install snarkjs on your backend:

```bash
npm install snarkjs
```

Or use Docker:

```dockerfile
FROM node:18
RUN npm install -g snarkjs
COPY verification_keys/ /app/verification_keys/
WORKDIR /app
CMD ["node", "server.js"]
```

## File Formats

All verification keys are JSON files following the Groth16 format:

```json
{
  "protocol": "groth16",
  "curve": "bn128",
  "nPublic": 2,
  "vk_alpha_1": [...],
  "vk_beta_2": [...],
  "vk_gamma_2": [...],
  "vk_delta_2": [...],
  "vk_alphabeta_12": [...],
  "IC": [...]
}
```

## Resources

- **snarkjs Documentation:** https://github.com/iden3/snarkjs
- **Groth16 Paper:** https://eprint.iacr.org/2016/260.pdf
- **BN128 Curve:** https://eips.ethereum.org/EIPS/eip-197
- **Hashing Scheme:** See `HASHING_SCHEME.md` in parent directory

## Support

If verification fails:
1. Check circuit name matches
2. Verify public signals format
3. Ensure you're using correct verification key
4. For set_membership, verify hashing matches (see `HASHING_SCHEME.md`)
5. Check snarkjs version compatibility

---

**Last Updated:** November 5, 2025  
**Version:** 1.0
